# Technical Strategy Framework

## Overview

The Technical Strategy Framework provides the primary signal generation layer of the ensemble trading system. Built around proven technical indicators, it generates trading signals that are then filtered by LSTM pattern confidence scores for enhanced signal quality.

## Framework Architecture

### Strategy Hierarchy

```python
BaseStrategy (Abstract)
├── RSIMeanReversionStrategy      # Mean reversion using RSI
├── MACDMomentumStrategy         # Momentum using MACD crossovers
├── [Future] BollingerBandsStrategy
├── [Future] StochasticStrategy
└── EnsembleManager              # Strategy combination and weighting
```

### Core Strategy Interface

**BaseStrategy Contract**: `src/strategies/base.py`

```python
class BaseStrategy(ABC):
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        """Generate trading signals from market data"""

    @abstractmethod
    def calculate_signal_strength(self, data: pd.DataFrame, signals: pd.DataFrame) -> pd.Series:
        """Calculate confidence/strength of generated signals"""

    @abstractmethod
    def get_required_features(self) -> List[str]:
        """Return list of required data columns"""

    @abstractmethod
    def validate_parameters(self) -> bool:
        """Validate strategy configuration parameters"""
```

## Current Strategy Implementations

### RSI Mean Reversion Strategy

**File**: `src/strategies/implementations/rsi_strategy.py`
**Test Coverage**: `tests/unit/strategies/test_rsi_strategy.py` (394 lines)

**Strategy Logic**:

- **Long Signal**: RSI < oversold_threshold (default 30)
- **Short Signal**: RSI > overbought_threshold (default 70)
- **Exit Condition**: RSI returns to neutral zone (40-60)
- **Signal Strength**: Based on RSI extremity and volatility adjustment

**Configuration**: `RSIStrategyConfig`

```python
@dataclass
class RSIStrategyConfig:
    name: str = "rsi_mean_reversion"
    rsi_period: int = 14
    oversold_threshold: float = 30.0
    overbought_threshold: float = 70.0
    neutral_zone_lower: float = 40.0
    neutral_zone_upper: float = 60.0
    exit_on_neutral: bool = True
    max_holding_period: int = 10
    volatility_adjustment: bool = True
```

**Validation Rules**:

- Oversold threshold < neutral zone lower
- Overbought threshold > neutral zone upper
- Neutral zone lower < neutral zone upper
- All thresholds within [0, 100] range

**Performance Characteristics**:

- **Signal Generation**: Mean reversion focus, contrarian approach
- **Risk Management**: ATR-based stop loss (2x ATR), take profit (3x ATR)
- **Volatility Adjustment**: Reduces signal strength during high volatility
- **Holding Period**: Maximum 10-day positions for mean reversion

### MACD Momentum Strategy

**File**: `src/strategies/implementations/macd_momentum_strategy.py`
**Test Coverage**: `tests/unit/strategies/test_macd_momentum_strategy.py` (583 lines)

**Strategy Logic**:

- **Long Signal**: MACD crosses above signal line (bullish crossover)
- **Short Signal**: MACD crosses below signal line (bearish crossover)
- **Momentum Confirmation**: Optional histogram threshold filtering
- **Signal Strength**: Based on MACD histogram magnitude

**Configuration**: `MACDStrategyConfig`

```python
@dataclass
class MACDStrategyConfig:
    name: str = "macd_momentum_strategy"
    fast_period: int = 12
    slow_period: int = 26
    signal_period: int = 9
    signal_threshold: float = 0.0
    histogram_threshold: float = 0.0
    momentum_confirmation: bool = True
    divergence_detection: bool = False
    exit_on_opposite_signal: bool = True
    exit_on_signal_line_cross: bool = True
    max_holding_period: int = 20
    volatility_adjustment: bool = True
```

**Advanced Features**:

- **Crossover Detection**: Precise bullish/bearish crossover identification
- **Momentum Confirmation**: Histogram threshold for signal validation
- **Divergence Detection**: Price-MACD divergence identification (optional)
- **Dynamic Exits**: Multiple exit conditions (opposite signal, signal line cross)

**Validation Rules**:

- Fast period < slow period
- Signal period > 0
- All threshold values properly bounded

### Strategy Signal Format

**Standardized Signal Output**:

```python
# Generated by all strategies
signal_df = pd.DataFrame({
    'position': [0.0, 1.0, 1.0, 0.0, -1.0],      # Position size (-1, 0, 1)
    'signal_strength': [0.0, 0.7, 0.8, 0.0, 0.6], # Confidence [0, 1]
    'entry_price': [NaN, 100.5, NaN, NaN, 102.1],  # Entry price when position taken
    'stop_loss': [NaN, 98.5, NaN, NaN, 104.1],     # ATR-based stop loss
    'take_profit': [NaN, 103.5, NaN, NaN, 99.1],   # ATR-based take profit
    'exit_reason': [None, None, None, 'neutral_zone', None]
}, index=market_data.index)
```

## Ensemble Management System

### EnsembleManager Architecture

**File**: `src/strategies/ensemble.py`

```python
class EnsembleManager:
    def __init__(self, config: EnsembleConfig):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.strategy_weights = config.strategy_weights
        self.combination_method = config.combination_method
        self.min_ensemble_confidence = config.min_ensemble_confidence

    def register_strategy(self, strategy: BaseStrategy):
        """Register strategy with ensemble"""

    def generate_ensemble_signals(self, market_data: pd.DataFrame) -> pd.DataFrame:
        """Generate combined ensemble signals"""

    def apply_pattern_confidence_filtering(self, signals: pd.DataFrame,
                                         pattern_confidence: np.ndarray) -> pd.DataFrame:
        """Apply LSTM pattern confidence filtering"""
```

### Signal Combination Methods

**Weighted Average** (Default):

```python
def combine_weighted_average(self, individual_signals):
    ensemble_position = sum(
        weight * signals['position'] * signals['signal_strength']
        for (strategy_name, weight), signals in zip(self.strategy_weights.items(), individual_signals.values())
    )
    return np.clip(ensemble_position, -1.0, 1.0)
```

**Confidence Weighted**:

```python
def combine_confidence_weighted(self, individual_signals):
    total_confidence = sum(signals['signal_strength'] for signals in individual_signals.values())
    if total_confidence == 0:
        return 0.0

    weighted_position = sum(
        (signals['signal_strength'] / total_confidence) * signals['position']
        for signals in individual_signals.values()
    )
    return weighted_position
```

**Voting System**:

```python
def combine_voting(self, individual_signals):
    votes = [np.sign(signals['position']) for signals in individual_signals.values()]
    return np.sign(sum(votes)) if abs(sum(votes)) >= self.min_vote_threshold else 0.0
```

### Configuration Management

**EnsembleConfig**:

```python
@dataclass
class EnsembleConfig:
    strategy_weights: Dict[str, float] = field(default_factory=lambda: {
        "rsi_mean_reversion": 0.4,
        "macd_momentum_strategy": 0.6
    })
    combination_method: str = "weighted_average"  # "confidence_weighted", "voting"
    min_ensemble_confidence: float = 0.3
    max_total_position: float = 1.0
    risk_adjustment: bool = True
    correlation_monitoring: bool = True
```

**Validation Rules**:

- Strategy weights must sum to 1.0
- All weights must be non-negative
- Combination method must be valid
- Confidence thresholds properly bounded

## Integration with LSTM Pattern Detection

### Meta-Labeling Architecture

The ensemble generates **primary signals** that are filtered by **LSTM pattern confidence**:

```python
def generate_filtered_ensemble_signals(self, market_data, pattern_confidence):
    # 1. Generate individual strategy signals
    individual_signals = {}
    for name, strategy in self.strategies.items():
        individual_signals[name] = strategy.generate_signals(market_data)

    # 2. Combine into ensemble signals
    ensemble_signals = self.combine_signals(individual_signals)

    # 3. Apply pattern confidence filtering
    confidence_threshold = self.min_ensemble_confidence
    filtered_signals = self.apply_pattern_filtering(
        ensemble_signals, pattern_confidence, confidence_threshold
    )

    return {
        'individual_signals': individual_signals,
        'ensemble_signals': ensemble_signals,
        'pattern_confidence': pattern_confidence,
        'filtered_signals': filtered_signals
    }
```

### Pattern Confidence Integration

**High Confidence (>0.7)**: Amplify signal strength
**Medium Confidence (0.3-0.7)**: Use signals as-is
**Low Confidence (<0.3)**: Filter out signals

```python
def apply_pattern_confidence_filtering(self, signals, pattern_confidence, threshold=0.3):
    filtered_signals = signals.copy()

    # Filter low confidence signals
    low_confidence_mask = pattern_confidence < threshold
    filtered_signals.loc[low_confidence_mask, 'position'] = 0.0
    filtered_signals.loc[low_confidence_mask, 'signal_strength'] = 0.0

    # Amplify high confidence signals
    high_confidence_mask = pattern_confidence > 0.7
    amplification_factor = 1.2
    filtered_signals.loc[high_confidence_mask, 'signal_strength'] *= amplification_factor

    return filtered_signals
```

## Strategy Development Framework

### Adding New Technical Strategies

**Step 1: Strategy Implementation**

```python
class BollingerBandsStrategy(BaseStrategy):
    def __init__(self, config: BollingerBandsConfig):
        self.config = config
        self.validate_parameters()

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        # Implement strategy logic

    def calculate_signal_strength(self, data: pd.DataFrame, signals: pd.DataFrame) -> pd.Series:
        # Implement signal strength calculation

    def get_required_features(self) -> List[str]:
        return ['close', 'bb_upper', 'bb_lower', 'bb_middle', 'atr']

    def validate_parameters(self) -> bool:
        # Implement parameter validation
```

**Step 2: Configuration Class**

```python
@dataclass
class BollingerBandsConfig:
    name: str = "bollinger_bands"
    period: int = 20
    std_dev: float = 2.0
    breakout_threshold: float = 0.02
    mean_reversion_mode: bool = True
    volatility_adjustment: bool = True
```

**Step 3: Comprehensive Unit Testing**

```python
# tests/unit/strategies/test_bollinger_bands_strategy.py
class TestBollingerBandsStrategy:
    def test_generate_signals_creates_positions_on_band_touches(self):
        # Test signal generation logic

    def test_calculate_signal_strength_varies_with_band_distance(self):
        # Test signal strength calculation

    def test_strategy_handles_edge_cases_gracefully(self):
        # Test error handling and edge cases
```

**Step 4: Integration with Ensemble**

```python
# Register with ensemble manager
bb_strategy = BollingerBandsStrategy(BollingerBandsConfig())
ensemble_manager.register_strategy(bb_strategy)

# Update ensemble configuration
updated_weights = {
    "rsi_mean_reversion": 0.3,
    "macd_momentum_strategy": 0.4,
    "bollinger_bands": 0.3
}
ensemble_manager.update_strategy_weights(updated_weights)
```

### Strategy Validation Requirements

**Performance Validation**:

- Walk-forward backtesting with positive risk-adjusted returns
- Cross-ticker performance consistency
- Market condition robustness (bull/bear/sideways)
- Drawdown and volatility characteristics

**Technical Validation**:

- Unit test coverage >90%
- Edge case handling (empty data, NaN values, extreme values)
- Parameter validation and error handling
- Integration testing with ensemble framework

**Signal Quality Metrics**:

- Signal precision and recall
- Signal strength correlation with outcomes
- Position holding period distribution
- Exit condition effectiveness

## Strategy Performance Analysis

### Current Strategy Metrics

**RSI Mean Reversion Strategy**:

- **Signal Precision**: Optimized for oversold/overbought reversals
- **Average Holding Period**: 5-10 days (mean reversion focus)
- **Risk Management**: ATR-based stops, volatility adjustment
- **Market Condition Performance**: Best in ranging/sideways markets

**MACD Momentum Strategy**:

- **Signal Precision**: Trend following with crossover confirmation
- **Average Holding Period**: 10-20 days (momentum following)
- **Risk Management**: Dynamic exits, momentum confirmation
- **Market Condition Performance**: Best in trending markets

**Ensemble Performance**:

- **Strategy Correlation**: Low correlation between RSI and MACD approaches
- **Combined Sharpe**: Higher than individual strategies
- **Risk Reduction**: Diversification across mean reversion and momentum
- **Pattern Filtering**: 15-25% improvement with LSTM confidence filtering

### Risk Management Framework

**Position Sizing**:

- **Fixed Fractional**: Standard 1.0/-1.0 position sizes
- **Volatility Adjusted**: ATR-based position scaling (optional)
- **Ensemble Limits**: Maximum combined position limits
- **Correlation Monitoring**: Dynamic position adjustment based on strategy correlation

**Stop Loss Management**:

```python
def calculate_stop_loss(self, entry_price, position_direction, atr):
    if position_direction > 0:  # Long position
        return entry_price - (self.stop_loss_atr_multiple * atr)
    else:  # Short position
        return entry_price + (self.stop_loss_atr_multiple * atr)
```

**Take Profit Management**:

```python
def calculate_take_profit(self, entry_price, position_direction, atr):
    if position_direction > 0:  # Long position
        return entry_price + (self.take_profit_atr_multiple * atr)
    else:  # Short position
        return entry_price - (self.take_profit_atr_multiple * atr)
```

## Production API Integration

### Strategy Endpoints

**Individual Strategy Signals**: `POST /predict/strategy_signals`

```python
@app.post("/predict/strategy_signals")
async def predict_strategy_signals(request: StrategyRequest):
    strategy = ensemble_manager.strategies[request.strategy_name]
    signals = strategy.generate_signals(request.market_data)

    return {
        "strategy_name": request.strategy_name,
        "signals": signals.to_dict(),
        "signal_strength": signals['signal_strength'].iloc[-1],
        "current_position": signals['position'].iloc[-1],
        "risk_metrics": calculate_strategy_risk_metrics(signals)
    }
```

**Ensemble Signals**: `POST /predict/ensemble_signals`

```python
@app.post("/predict/ensemble_signals")
async def predict_ensemble_signals(request: TradingRequest):
    # Generate ensemble signals
    ensemble_signals = ensemble_manager.generate_ensemble_signals(request.market_data)

    # Apply LSTM pattern confidence filtering
    pattern_confidence = lstm_service.predict_pattern_confidence(request.market_data)
    filtered_signals = ensemble_manager.apply_pattern_confidence_filtering(
        ensemble_signals, pattern_confidence
    )

    return {
        "ensemble_signals": ensemble_signals.to_dict(),
        "pattern_confidence": pattern_confidence.tolist(),
        "filtered_signals": filtered_signals.to_dict(),
        "recommendation": determine_trading_recommendation(filtered_signals),
        "active_strategies": get_active_strategies(filtered_signals),
        "risk_assessment": calculate_ensemble_risk_metrics(filtered_signals)
    }
```

## Future Enhancements

### Advanced Strategy Features

**Multi-Timeframe Analysis**:

- Integrate multiple timeframe confirmation
- Higher timeframe trend alignment
- Intraday vs daily signal consistency

**Adaptive Parameters**:

- Market regime-based parameter adjustment
- Volatility-based threshold adaptation
- Performance-based strategy weighting

**Advanced Risk Management**:

- Dynamic position sizing based on strategy performance
- Correlation-based position limits
- Drawdown-based strategy deactivation

### Strategy Expansion Roadmap

**Phase 2 Strategies** (Next Implementation):

- **Bollinger Bands Strategy**: Mean reversion with volatility bands
- **Stochastic Strategy**: Momentum with overbought/oversold confirmation
- **Volume Profile Strategy**: Price-volume relationship analysis

**Phase 3 Advanced Strategies**:

- **Multi-Factor Strategy**: Fundamental + technical combination
- **Sector Rotation Strategy**: Cross-sector relative strength
- **Market Microstructure Strategy**: Order flow and market making patterns

